#ifndef _helperMethods_h_
#define _helperMethods_h_
/* -------------------------------------------------------------------------- *
 *                   OpenSim:  helperMethods.h                    *
 * -------------------------------------------------------------------------- *
 * The OpenSim API is a toolkit for musculoskeletal modeling and simulation.  *
 * See http://opensim.stanford.edu and the NOTICE file for more information.  *
 * OpenSim is developed at Stanford University and supported by the US        *
 * National Institutes of Health (U54 GM072970, R24 HD065690) and by DARPA    *
 * through the Warrior Web program.                                           *
 *                                                                            *
 * Copyright (c) 2005-2016 Stanford University and the Authors                *
 * Author(s): Chris Dembia, Shrinidhi K. Lakshmikanth, Ajay Seth,             *
 *            Thomas Uchida                                                   *
 *                                                                            *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may    *
 * not use this file except in compliance with the License. You may obtain a  *
 * copy of the License at http://www.apache.org/licenses/LICENSE-2.0.         *
 *                                                                            *
 * Unless required by applicable law or agreed to in writing, software        *
 * distributed under the License is distributed on an "AS IS" BASIS,          *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
 * See the License for the specific language governing permissions and        *
 * limitations under the License.                                             *
 * -------------------------------------------------------------------------- */


#include <OpenSim/OpenSim.h>

static const double OPTIMAL_FORCE{ 4000. };

using namespace std;
namespace OpenSim {

	//------------------------------------------------------------------------------
	// Display the class name and full path name for each of the given Component's
	// descendants (children, grandchildren, etc.).
	//
	// Examples:
	//   showSubcomponentInfo(myComponent);         //show all descendant Components
	//   showSubcomponentInfo<Joint>(myComponent);  //show Joint descendants only
	//------------------------------------------------------------------------------
	template <class C = Component>
	inline void showSubcomponentInfo(const Component& comp);


	//------------------------------------------------------------------------------
	// Display the name of each output generated by a Component; include outputs
	// generated by all the Component's descendants (children, grandchildren, etc.)
	// by default (set includeDescendants=false to suppress).
	//------------------------------------------------------------------------------
	inline void showAllOutputs(const Component& comp, bool includeDescendants = true);


	//------------------------------------------------------------------------------
	// Simulate a model from an initial state. The user is repeatedly prompted to
	// either begin simulating or quit. The provided state is updated (returns the
	// state at the end of the simulation). Set saveStatesFile=true to save the
	// states to a storage file.
	//------------------------------------------------------------------------------
	inline void simulate(Model& model, SimTK::State& state,
		bool saveStatesFile = false);


	//------------------------------------------------------------------------------
	// Build a testbed for testing the device before attaching it to the hopper. We
	// will attach one end of the device to ground ("/testbed/ground") and the other
	// end to a sprung load ("/testbed/load").
	//------------------------------------------------------------------------------
	inline Model buildTestbed();



//------------------------------------------------------------------------------
// SignalGenerator is a type of Component with no inputs and only one output.
// This Component evaluates an OpenSim::Function (stored in its "function"
// property) as a function of time. We can use a SignalGenerator to design
// time-varying control inputs for testing the device.
//------------------------------------------------------------------------------
class SignalGenerator : public Component {
    OpenSim_DECLARE_CONCRETE_OBJECT(SignalGenerator, Component);

public:
    OpenSim_DECLARE_PROPERTY(function, Function,
        "Function used to generate the signal (a function of time)");
    OpenSim_DECLARE_OUTPUT(signal, double, getSignal, SimTK::Stage::Time);

    SignalGenerator() { constructProperties(); }
	

    double getSignal(const SimTK::State& s) const {
        return get_function().calcValue(SimTK::Vector(1, s.getTime())); }

private:
    void constructProperties() { constructProperty_function(Constant(0.1)); }

}; // end of SignalGenerator




inline Model buildTestbed()
{
	using SimTK::Vec3;
	using SimTK::Inertia;

	//Physical properties of the model
	double ballMass = 1000;
	double ballRadius = 0.05;
	double anchorWidth = 0.05;

	// Create a new OpenSim model.
	auto testbed = Model();
	testbed.setName("testbed");
	testbed.setUseVisualizer(true);
	testbed.setGravity(Vec3(0));

	// Get a reference to the model's ground body and attach geometry to it
	Ground& ground = testbed.updGround();
	auto brick = new Brick(Vec3(anchorWidth, anchorWidth, 2 * anchorWidth));
	brick->setColor(SimTK::Blue);
	ground.attachGeometry(brick);
	
	
	// create a second body and attach a sphere geometry to it
	OpenSim::Body * ball = new OpenSim::Body("load",
		ballMass,
		Vec3(0),
		ballMass*SimTK::Inertia::sphere(ballRadius));

	auto sphere = new Sphere(ballRadius);
	sphere->setName("sphere");
	sphere->setColor(SimTK::Green);
	ball->attachGeometry(sphere);
	testbed.addBody(ball);

	// ball connected  to ground via a slider along X
	double maxIsometricForce = 100.0, optimalFiberLength = 0.25, tendonSlackLength = 0.1, pennationAngle = SimTK::Pi / 4;
	double xSinG = optimalFiberLength*cos(pennationAngle) + tendonSlackLength;

	//SliderJoint s = SliderJoint()
	auto slider = new SliderJoint("gndToLoad",
		ground,
		Vec3(anchorWidth / 2 + xSinG, 0, 0),
		Vec3(0),
		*ball,
		Vec3(0),
		Vec3(0));
	
	testbed.addJoint(slider);
	
	CoordinateSet& jointCoordinateSet = slider->upd_CoordinateSet();
	jointCoordinateSet[0].setName("tx");
	jointCoordinateSet[0].setDefaultValue(0.5);
	jointCoordinateSet[0].setRangeMin(0.0);
	jointCoordinateSet[0].setRangeMax(2.0);

	StepFunction& motion = StepFunction(
		0.05, //t0
		0.5, //t1
		0,    //f(t0)
		0.1); //f(t1)

	jointCoordinateSet[0].setPrescribedFunction(motion);
	jointCoordinateSet[0].setDefaultIsPrescribed(true);

	// create a muscle and add it to model
	//Millard2012EquilibriumMuscle *muscle = new Millard2012EquilibriumMuscle("muscle",
	//	maxIsometricForce,
	//	optimalFiberLength,
	//	tendonSlackLength,
	//	pennationAngle);

	auto muscle = new PathActuator();
	muscle->set_optimal_force(OPTIMAL_FORCE);

	muscle->addNewPathPoint("muscle-point1", ground, Vec3(0));
	muscle->addNewPathPoint("muscle-point2", *ball, Vec3(0));
	muscle->setName("muscle");
	testbed.addForce(muscle);
	

	testbed.setDebugLevel(0);
	return testbed;
}

//==============================================================================
//                               IMPLEMENTATIONS
//==============================================================================
template <class C>
inline void showSubcomponentInfo(const Component& comp)
{
	using std::cout; using std::endl;

	std::string className = SimTK::NiceTypeName<C>::namestr();
	const std::size_t colonPos = className.rfind(":");
	if (colonPos != std::string::npos)
		className = className.substr(colonPos + 1, className.length() - colonPos);

	cout << "Class name and full path name for descendants of '"
		<< comp.getName() << "' that are of type " << className << ":\n"
		<< endl;

	ComponentList<const C> compList = comp.getComponentList<C>();

	// Step through compList once to find the longest concrete class name.
	unsigned maxlen = 0;
	for (const C& thisComp : compList) {
		auto len = thisComp.getConcreteClassName().length();
		maxlen = std::max(maxlen, static_cast<unsigned>(len));
	}
	maxlen += 4; //padding

				 // Step through compList again to print.
	for (const C& thisComp : compList) {
		const std::string thisClass = thisComp.getConcreteClassName();
		for (unsigned i = 0u; i < maxlen - thisClass.length(); ++i) { cout << " "; }
		cout << "[" << thisClass << "]  " << thisComp.getFullPathName() << endl;
	}
	cout << endl;
}

inline void showAllOutputs(const Component& comp, bool includeDescendants)
{
	using std::cout; using std::endl;

	// Do not display header for Components with no outputs.
	if (comp.getNumOutputs() > 0) {
		const std::string msg = "Outputs from " + comp.getFullPathName();
		cout << msg << endl;
		for (unsigned i = 0u; i<msg.size(); ++i) { cout << "="; }
		cout << endl;

		std::vector<std::string> outputNames = comp.getOutputNames();
		for (auto thisName : outputNames) { cout << "  " << thisName << endl; }
		cout << endl;
	}

	if (includeDescendants) {
		ComponentList<const Component> compList =
			comp.getComponentList<Component>();
		for (const Component& thisComp : compList) {
			// compList (comp's ComponentList) includes all descendants (i.e.,
			// children, grandchildren, etc.) so set includeDescendants=false
			// when calling on thisComp.
			showAllOutputs(thisComp, false);
		}
	}
}

inline void simulate(Model& model, SimTK::State& state, bool saveStatesFile)
{
	SimTK::State initState = state;
	SimTK::Visualizer::InputSilo* silo;
	try {
		// Configure the visualizer.
		if (model.getUseVisualizer()) {
			SimTK::Visualizer& viz = model.updVisualizer().updSimbodyVisualizer();
			// We use the input silo to get key presses. OpenSim::ModelVisualizer
			// adds two InputListeners; the second is InputSilo.
			silo = dynamic_cast<SimTK::Visualizer::InputSilo*>(&viz.updInputListener(1));

			SimTK::DecorativeText help("Press any key to start a new simulation; "
				"ESC to quit.");
			help.setIsScreenText(true);
			viz.addDecoration(SimTK::MobilizedBodyIndex(0), SimTK::Vec3(0), help);

			viz.setBackgroundType(viz.SolidColor).setShowSimTime(true);
			viz.drawFrameNow(state);
			std::cout << "A visualizer window has opened." << std::endl;
		}
	}
	catch (Exception e) {
		cout << e.what() << endl;
	}
	// Simulate until the user presses ESC (or enters 'q' if visualization has
	// been disabled).
	while (true) {
		if (model.getUseVisualizer()) {
			// Get a key press.
			silo->clear(); // Ignore any previous key presses.
			unsigned key, modifiers;
			silo->waitForKeyHit(key, modifiers);
			if (key == SimTK::Visualizer::InputListener::KeyEsc) { break; }
		}
		else {
			std::cout << "Press <Enter> to begin simulating, or 'q' followed "
				<< "by <Enter> to quit . . . " << std::endl;
			if (std::cin.get() == 'q') { break; }
		}

		// Set up manager and simulate.
		state = initState;
		SimTK::RungeKuttaMersonIntegrator integrator(model.getSystem());
		Manager manager(model, integrator);
		manager.setInitialTime(0.); manager.setFinalTime(5.);
		manager.integrate(state);

		// Save the states to a storage file (if requested).
		if (saveStatesFile) {
			manager.getStateStorage().print("hopperStates.sto");
		}
	}
}


} // end of namespace OpenSim

#endif // _helperMethods_h_
