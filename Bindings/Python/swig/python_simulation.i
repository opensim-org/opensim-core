%module(directors="1") simulation
#pragma SWIG nowarn=822,451,503,516,325
// 401 is "Nothing known about base class *some-class*.
//         Maybe you forgot to instantiate *some-template* using %template."
// When wrapping new classes it's good to uncomment the line below to make sure
// you've wrapped your new class properly. However, SWIG generates lots of 401
// errors that are very difficult to resolve.
#pragma SWIG nowarn=401

%{
#define SWIG_FILE_WITH_INIT
#include <Bindings/OpenSimHeaders_common.h>
#include <Bindings/OpenSimHeaders_simulation.h>
%}

%{
using namespace OpenSim;
using namespace SimTK;
%}


%include "python_preliminaries.i"

// Tell SWIG about the modules we depend on.
%import "python_common.i"

// Relay exceptions to the target language.
// This causes substantial code bloat and possibly hurts performance.
// Without these try-catch block, a SimTK or OpenSim exception causes the
// program to crash.
%include "exception.i"
// Delete any previous exception handlers.
%exception; 
%exception {
    try {
        $action
    } catch (const std::exception& e) {
        std::string str("std::exception in '$fulldecl': ");
        std::string what(e.what());
        SWIG_exception_fail(SWIG_RuntimeError, (str + what).c_str());
    }
}

// Rename
// ======

%rename(appendNative) OpenSim::ForceSet::append(Force* aForce);

// Memory management
// =================
/*
The added component is not responsible for its own memory management anymore
once added to the Model.  These lines must go at this point in this .i file. I
originally had them at the bottom, and then they didn't work!

note: ## is a "glue" operator: `a ## b` --> `ab`.
*/
%define MODEL_ADOPT_HELPER(NAME)
%pythonappend OpenSim::Model::add ## NAME %{
    adoptee._markAdopted()
%}
%enddef

MODEL_ADOPT_HELPER(ModelComponent);
MODEL_ADOPT_HELPER(Body);
MODEL_ADOPT_HELPER(Probe);
MODEL_ADOPT_HELPER(Joint);
MODEL_ADOPT_HELPER(Frame);
MODEL_ADOPT_HELPER(Constraint);
MODEL_ADOPT_HELPER(ContactGeometry);
MODEL_ADOPT_HELPER(Analysis);
MODEL_ADOPT_HELPER(Force);
MODEL_ADOPT_HELPER(Controller);


// Compensate for insufficient C++11 support in SWIG
// =================================================
/*
Extend concrete Joints to use the inherited base constructors.
This is only necessary because SWIG does not generate these inherited
constructors provided by C++11's 'using' (e.g. using Joint::Joint) declaration.
Note that CustomJoint and EllipsoidJoint do implement their own
constructors because they have additional arguments.
*/
%define EXPOSE_JOINT_CONSTRUCTORS_HELPER(NAME)
%extend OpenSim::NAME {
	NAME(const std::string& name,
         const std::string& parentName,
         const std::string& childName) {
		return new NAME(name, parentName, childName, false);
	}
	
	NAME(const std::string& name,
         const PhysicalFrame& parent,
         const SimTK::Vec3& locationInParent,
         const SimTK::Vec3& orientationInParent,
         const PhysicalFrame& child,
         const SimTK::Vec3& locationInChild,
         const SimTK::Vec3& orientationInChild) {
		return new NAME(name, parent, locationInParent, orientationInParent,
					child, locationInChild, orientationInChild, false);
	}
};
%enddef

EXPOSE_JOINT_CONSTRUCTORS_HELPER(FreeJoint);
EXPOSE_JOINT_CONSTRUCTORS_HELPER(BallJoint);
EXPOSE_JOINT_CONSTRUCTORS_HELPER(PinJoint);
EXPOSE_JOINT_CONSTRUCTORS_HELPER(SliderJoint);
EXPOSE_JOINT_CONSTRUCTORS_HELPER(WeldJoint);
EXPOSE_JOINT_CONSTRUCTORS_HELPER(GimbalJoint);
EXPOSE_JOINT_CONSTRUCTORS_HELPER(UniversalJoint);
EXPOSE_JOINT_CONSTRUCTORS_HELPER(PlanarJoint);

// Typemaps
// ========
// None.

// Pythonic operators
// ==================
// Allow iterating through a StatesTrajectory.
// This extend block must appear before the %template call in simulation.i.

// TODO remove.
%rename(_getBetween) OpenSim::StatesTrajectory::getBetween;

%extend OpenSim::StatesTrajectory {
%pythoncode %{

    def __iter__(self):
        """Get an iterator for this Set, to be used as such (where `states` is
        the StatesTrajectory object)::
           
            for state in states:
                model.calcMassCenterPosition(state)
        """
        it = self.begin()
        while it != self.end():
            yield it.next()

    def getBetween(self, *args, **kwargs):
        iter_range = self._getBetween(*args, **kwargs)
        it = iter_range.begin()
        while it != iter_range.end():
            yield it.next()
%}
};

// TODO we already made a StdVectorState in simbody.i, but this is required
// to create type traits for the simulation module. Ideally, we would not need
// the following line:
%template(_StdVectorState) std::vector<SimTK::State>;


// Include all the OpenSim code.
// =============================
%include <Bindings/preliminaries.i>
%include <Bindings/simulation.i>


// Memory management
// =================
SET_ADOPT_HELPER(BodyScale);
SET_ADOPT_HELPER(PathPoint);
SET_ADOPT_HELPER(Marker);
SET_ADOPT_HELPER(Control);
SET_ADOPT_HELPER(Frame);
SET_ADOPT_HELPER(Force);
SET_ADOPT_HELPER(Analysis);

// This didn't work with the macro for some reason. I got complaints about
// multiple definitions of, e.g., Probe in the target language.
%extend OpenSim::ProbeSet {
%pythoncode %{
    def adoptAndAppend(self, aProbe):
        aProbe._markAdopted()
        return super(ProbeSet, self).adoptAndAppend(aProbe)
%}
};

// Attempt to solve segfault when calling ForceSet::append()
// from scripting.
%extend OpenSim::ForceSet {
%pythoncode %{
    def append(self, aForce):
        aForce._markAdopted()
        return self.appendNative(aForce)
%}
};

// Pythonic operators
// ==================
// Allow indexing operator in python (e.g., states[i]).
%extend OpenSim::StatesTrajectory {
    const SimTK::State&  __getitem__(int i) const {
        return $self->get(i);
    }
};
